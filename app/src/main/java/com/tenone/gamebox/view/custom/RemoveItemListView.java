package com.tenone.gamebox.view.custom;

import android.annotation.SuppressLint;
import android.content.Context;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.View;
import android.view.animation.LinearInterpolator;
import android.widget.AbsListView;
import android.widget.ListAdapter;
import android.widget.ListView;
import android.widget.Scroller;
import android.widget.TextView;

import com.tenone.gamebox.R;
import com.tenone.gamebox.mode.listener.OnRemoveItemListViewDeleteClickListener;
import com.tenone.gamebox.view.utils.MyLog;

public class RemoveItemListView extends ListView implements AbsListView.OnScrollListener {
    //上一次的触摸点
    private int mLastX, mLastY;
    //当前触摸的item的位置
    private int mPosition = -1;

    //item对应的布局
    private View mItemLayout;
    //删除按钮
    private TextView mDelete;

    //最大滑动距离(即删除按钮的宽度)
    private int mMaxLength;
    //是否在垂直滑动列表
    private boolean isDragging;
    //item是在否跟随手指移动
    private boolean isItemMoving;

    //item是否开始自动滑动
    private boolean isStartScroll;
    //删除按钮状态   0：关闭 1：将要关闭 2：将要打开 3：打开
    private int mDeleteBtnState;

    //检测手指在滑动过程中的速度
    private VelocityTracker mVelocityTracker;
    private Scroller mScroller;
    private OnRemoveItemListViewDeleteClickListener mListener;

    public RemoveItemListView(Context context) {
        this( context, null, 0 );
    }

    public RemoveItemListView(Context context, AttributeSet attrs) {
        this( context, attrs, 0 );
    }

    public RemoveItemListView(Context context, AttributeSet attrs, int defStyleAttr) {
        super( context, attrs, defStyleAttr );
        mScroller = new Scroller( context, new LinearInterpolator() );
        mVelocityTracker = VelocityTracker.obtain();
        setOnScrollListener( this );
    }

    @Override
    public boolean onTouchEvent(MotionEvent e) {
        MyLog.d( "onTouchEvent" );
        mVelocityTracker.addMovement( e );
        int x = (int) e.getX();
        int y = (int) e.getY();
        switch (e.getAction()) {
            case MotionEvent.ACTION_DOWN:
                if (mDeleteBtnState == 0) {
                    mPosition = pointToPosition( x, y );
                    if (mPosition > -1) {
                        mItemLayout = getChildAt( mPosition );
                        if (mItemLayout == null) {
                            return false;
                        }
                        mDelete = mItemLayout.findViewById( R.id.item_delete );
                        mMaxLength = mDelete.getWidth();
                        mDelete.setOnClickListener( v -> {
                            if (mListener != null) {
                                mListener.onRemoveItemListViewDeleteClick( mPosition );
                            }
                            mItemLayout.scrollTo( 0, 0 );
                            mDeleteBtnState = 0;
                        } );
                    } else if (mDeleteBtnState == 3) {
                        mScroller.startScroll( mItemLayout.getScrollX(), 0, -mMaxLength, 0, 200 );
                        invalidate();
                        mDeleteBtnState = 0;
                        return false;
                    } else {
                        return false;
                    }
                }
                break;
            case MotionEvent.ACTION_MOVE:
                if (mItemLayout != null) {
                    int dx = mLastX - x;
                    int dy = mLastY - y;
                    int scrollX = mItemLayout.getScrollX();
                    if (Math.abs( dx ) > Math.abs( dy )) {//左边界检测
                        isItemMoving = true;
                        if (scrollX + dx <= 0) {
                            mItemLayout.scrollTo( 0, 0 );
                            return true;
                        } else if (scrollX + dx >= mMaxLength) {//右边界检测
                            mItemLayout.scrollTo( mMaxLength, 0 );
                            return true;
                        }
                        mItemLayout.scrollBy( dx, 0 );//item跟随手指滑动
                    }
                }
                break;
            case MotionEvent.ACTION_UP:
                if (mItemLayout != null) {
                    if (!isItemMoving && !isDragging && mListener != null) {
                        mListener.onRemoveItemListViewItemClick( mItemLayout, mPosition );
                    }
                    isItemMoving = false;
                    mVelocityTracker.computeCurrentVelocity( 1000 );//计算手指滑动的速度
                    float xVelocity = mVelocityTracker.getXVelocity();//水平方向速度（向左为负）
                    float yVelocity = mVelocityTracker.getYVelocity();//垂直方向速度
                    int deltaX = 0;
                    int upScrollX = mItemLayout.getScrollX();
                    if (Math.abs( xVelocity ) > 100 && Math.abs( xVelocity ) > Math.abs( yVelocity )) {
                        if (xVelocity <= -100) {//左滑速度大于100，则删除按钮显示
                            deltaX = mMaxLength - upScrollX;
                            mDeleteBtnState = 2;
                        } else if (xVelocity > 100) {//右滑速度大于100，则删除按钮隐藏
                            deltaX = -upScrollX;
                            mDeleteBtnState = 1;
                        }
                    } else {
                        if (upScrollX >= mMaxLength / 2) {//item的左滑动距离大于删除按钮宽度的一半，则显示删除按钮
                            deltaX = mMaxLength - upScrollX;
                            mDeleteBtnState = 2;
                        } else if (upScrollX < mMaxLength / 2) {//否则隐藏
                            deltaX = -upScrollX;
                            mDeleteBtnState = 1;
                        }
                    }
                    //item自动滑动到指定位置
                    mScroller.startScroll( upScrollX, 0, deltaX, 0, 200 );
                    isStartScroll = true;
                    invalidate();
                    mVelocityTracker.clear();
                }
                break;
        }
        mLastX = x;
        mLastY = y;
        return super.onTouchEvent( e );
    }

    public void setmListener(OnRemoveItemListViewDeleteClickListener mListener) {
        this.mListener = mListener;
    }

    @SuppressLint("InflateParams")
    @Override
    public void setAdapter(ListAdapter adapter) {
        View mListViewFooter = LayoutInflater.from( getContext() ).inflate(
                R.layout.layout_footer, null, false );
        mListViewFooter.setVisibility( View.GONE );
        addFooterView( mListViewFooter );
        super.setAdapter( adapter );
        removeFooterView( mListViewFooter );
    }


    @Override
    public void computeScroll() {
        if (mScroller.computeScrollOffset()) {
            mItemLayout.scrollTo( mScroller.getCurrX(), mScroller.getCurrY() );
            invalidate();
        } else if (isStartScroll) {
            isStartScroll = false;
            if (mDeleteBtnState == 1) {
                mDeleteBtnState = 0;
            }

            if (mDeleteBtnState == 2) {
                mDeleteBtnState = 3;
            }
        }
    }

    @Override
    protected void onDetachedFromWindow() {
        mVelocityTracker.recycle();
        super.onDetachedFromWindow();
    }


    @Override
    public void onScrollStateChanged(AbsListView view, int scrollState) {
        isDragging = scrollState == SCROLL_STATE_TOUCH_SCROLL;
    }

    @Override
    public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
    }
}
